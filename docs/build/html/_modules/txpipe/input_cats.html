<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>txpipe.input_cats &mdash; TXPipe  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> TXPipe
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">TXPipe Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example.html">Running an example pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../running.html">Running a pipeline:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hdf5.html">Reading HDF5 Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../stages/stages.html">Stages implemented in TX-Pipe:</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TXPipe</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>txpipe.input_cats</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for txpipe.input_cats</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.base_stage</span> <span class="kn">import</span> <span class="n">PipelineStage</span>
<span class="kn">from</span> <span class="nn">.data_types</span> <span class="kn">import</span> <span class="n">ShearCatalog</span><span class="p">,</span> <span class="n">HDFFile</span>
<span class="kn">from</span> <span class="nn">.utils.calibration_tools</span> <span class="kn">import</span> <span class="n">band_variants</span><span class="p">,</span> <span class="n">metacal_variants</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.utils.timer</span> <span class="kn">import</span> <span class="n">Timer</span>


<div class="viewcode-block" id="TXCosmoDC2Mock"><a class="viewcode-back" href="../../stages/input_cats.html#txpipe.input_cats.TXCosmoDC2Mock">[docs]</a><span class="k">class</span> <span class="nc">TXCosmoDC2Mock</span><span class="p">(</span><span class="n">PipelineStage</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This stage simulates metacal data and metacalibrated</span>
<span class="sd">    photometry measurements, starting from a cosmology catalogs</span>
<span class="sd">    of the kind used as an input to DC2 image and obs-catalog simulations.</span>

<span class="sd">    This is mainly useful for testing infrastructure in advance</span>
<span class="sd">    of the DC2 catalogs being available, but might also be handy</span>
<span class="sd">    for starting from a purer simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;TXCosmoDC2Mock&#39;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;response_model&#39;</span><span class="p">,</span> <span class="n">HDFFile</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;shear_catalog&#39;</span><span class="p">,</span> <span class="n">ShearCatalog</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;photometry_catalog&#39;</span><span class="p">,</span> <span class="n">HDFFile</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">config_options</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;cat_name&#39;</span><span class="p">:</span><span class="s1">&#39;cosmoDC2&#39;</span><span class="p">,</span>
        <span class="s1">&#39;visits_per_band&#39;</span><span class="p">:</span><span class="mi">165</span><span class="p">,</span>  <span class="c1"># used in the noise simulation</span>
        <span class="s1">&#39;snr_limit&#39;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span>  <span class="c1"># used to decide what objects to cut out</span>
        <span class="s1">&#39;max_size&#39;</span><span class="p">:</span> <span class="mi">99999999999999</span><span class="p">,</span>  <span class="c1">#for testing on smaller catalogs</span>
        <span class="s1">&#39;extra_cols&#39;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="c1"># string-separated list of columns to include</span>
        <span class="s1">&#39;max_npix&#39;</span><span class="p">:</span><span class="mi">99999999999999</span><span class="p">,</span>
        <span class="s1">&#39;unit_response&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;cat_size&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s1">&#39;flip_g2&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="c1"># this matches the metacal definition, and the treecorr/namaster one</span>
        <span class="s1">&#39;apply_mag_cut&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="c1">#used when comparing to descqa measurements</span>
        <span class="s1">&#39;Mag_r_limit&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">19</span><span class="p">,</span> <span class="c1"># used to decide what objects to cut out  </span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">data_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gc</span><span class="p">):</span>

        <span class="c1"># Columns we need from the cosmo simulation</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mag_true_u_lsst&#39;</span><span class="p">,</span> <span class="s1">&#39;mag_true_g_lsst&#39;</span><span class="p">,</span> 
                <span class="s1">&#39;mag_true_r_lsst&#39;</span><span class="p">,</span> <span class="s1">&#39;mag_true_i_lsst&#39;</span><span class="p">,</span> 
                <span class="s1">&#39;mag_true_z_lsst&#39;</span><span class="p">,</span> <span class="s1">&#39;mag_true_y_lsst&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ra&#39;</span><span class="p">,</span> <span class="s1">&#39;dec&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ellipticity_1_true&#39;</span><span class="p">,</span> <span class="s1">&#39;ellipticity_2_true&#39;</span><span class="p">,</span>
                <span class="s1">&#39;shear_1&#39;</span><span class="p">,</span> <span class="s1">&#39;shear_2&#39;</span><span class="p">,</span>
                <span class="s1">&#39;size_true&#39;</span><span class="p">,</span>
                <span class="s1">&#39;galaxy_id&#39;</span><span class="p">,</span>
                <span class="s1">&#39;redshift_true&#39;</span><span class="p">,</span>
                <span class="p">]</span>
        <span class="c1"># Add any extra requestd columns</span>
        <span class="n">cols</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;extra_cols&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="n">it</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_quantities</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">return_iterator</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nfile</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">_file_list</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">gc</span><span class="p">,</span> <span class="s1">&#39;_file_list&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">it</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nfile</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading chunk </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">nfile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">GCRCatalogs</span>
        <span class="n">cat_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cat_name&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bands</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading from catalog </span><span class="si">{</span><span class="n">cat_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="n">gc</span> <span class="o">=</span> <span class="n">GCRCatalogs</span><span class="o">.</span><span class="n">load_catalog</span><span class="p">(</span><span class="n">cat_name</span><span class="p">)</span>

        <span class="c1"># GCR sometimes tries to read the entire catalog</span>
        <span class="c1"># to measure its length rather than looking at metadata</span>
        <span class="c1"># this can take a very long time.</span>
        <span class="c1"># allow the user to say that already know it.</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;cat_size&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gc</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rank </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="si">}</span><span class="s2"> loaded: length = </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="n">target_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;max_size&#39;</span><span class="p">])</span>
        <span class="n">select_fraction</span> <span class="o">=</span> <span class="n">target_size</span> <span class="o">/</span> <span class="n">N</span>

        <span class="k">if</span> <span class="n">target_size</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Will select approx </span><span class="si">{</span><span class="mi">100</span><span class="o">*</span><span class="n">select_fraction</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% of objects (</span><span class="si">{</span><span class="n">target_size</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>


        <span class="c1"># Prepare output files</span>
        <span class="n">metacal_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_output</span><span class="p">(</span><span class="s1">&#39;shear_catalog&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_mpi</span><span class="p">())</span>
        <span class="n">photo_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_output</span><span class="p">(</span><span class="s1">&#39;photometry_catalog&#39;</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_mpi</span><span class="p">())</span>
        <span class="n">photo_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_photometry_output</span><span class="p">(</span><span class="n">photo_file</span><span class="p">,</span> <span class="n">target_size</span><span class="p">)</span>
        <span class="n">metacal_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_metacal_output</span><span class="p">(</span><span class="n">metacal_file</span><span class="p">,</span> <span class="n">target_size</span><span class="p">)</span>


        <span class="c1"># Load the metacal response file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_metacal_response_model</span><span class="p">()</span>

        <span class="c1"># Keep track of catalog position</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Loop through chunks of </span>
        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_iterator</span><span class="p">(</span><span class="n">gc</span><span class="p">):</span>
            <span class="c1"># The initial chunk size, of all the input data.</span>
            <span class="c1"># This will be reduced later as we remove objects</span>
            <span class="n">some_col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">some_col</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Process </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="si">}</span><span class="s2"> read chunk </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">count</span><span class="o">+</span><span class="n">chunk_size</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">chunk_size</span>
            <span class="c1"># Select a random fraction of the catalog if we are cutting down</span>
            <span class="c1"># We can&#39;t just take the earliest galaxies because they are ordered</span>
            <span class="c1"># by redshift</span>
            <span class="k">if</span> <span class="n">target_size</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">select_fraction</span>
                <span class="n">nselect</span> <span class="o">=</span> <span class="n">select</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cutting down to </span><span class="si">{</span><span class="n">nselect</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">chunk_size</span><span class="si">}</span><span class="s2"> objects&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">select</span><span class="p">]</span>

            <span class="c1"># Simulate the various output data sets</span>
            <span class="n">mock_photometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_mock_photometry</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="c1"># Cut out any objects too faint to be detected and measured.</span>
            <span class="c1"># We have to do this after the photometry, so that we know if</span>
            <span class="c1"># the object is detected, but we can do it before making the mock</span>
            <span class="c1"># metacal info, saving us some time simulating un-needed objects</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_undetected</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mock_photometry</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;apply_mag_cut&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_magnitude_cut</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="n">mock_metacal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_mock_metacal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mock_photometry</span><span class="p">)</span>
            
            <span class="c1"># The chunk size has now changed</span>
            <span class="n">some_col</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mock_photometry</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mock_photometry</span><span class="p">[</span><span class="n">some_col</span><span class="p">])</span>


            <span class="c1"># start is where this process should start writing this</span>
            <span class="c1"># chunk of data.  end is where the final process will finish</span>
            <span class="c1"># writing, becoming the starting point for the whole next</span>
            <span class="c1"># chunk over all the processes</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_output_indices</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>

            <span class="c1"># Save all output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_output</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">target_size</span><span class="p">,</span> <span class="n">photo_cols</span><span class="p">,</span> <span class="n">metacal_cols</span><span class="p">,</span> <span class="n">photo_file</span><span class="p">,</span> <span class="n">mock_photometry</span><span class="p">,</span> <span class="n">metacal_file</span><span class="p">,</span> <span class="n">mock_metacal</span><span class="p">)</span>

            <span class="c1"># The next iteration starts writing where the current one ends.</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>
            
            <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">target_size</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="c1"># Tidy up</span>

        <span class="n">photo_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">metacal_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">truncate_outputs</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">truncate_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">h5py</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Barrier</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># all files should now be closed for all procs</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resizing all outupts to size </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_output</span><span class="p">(</span><span class="s1">&#39;photometry_catalog&#39;</span><span class="p">),</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;photometry&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">g</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_output</span><span class="p">(</span><span class="s1">&#39;shear_catalog&#39;</span><span class="p">),</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;shear&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">g</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>



    <span class="k">def</span> <span class="nf">next_output_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
            <span class="n">starting_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">all_indices</span><span class="p">)))</span>
            <span class="c1"># use the old start to find the end point.</span>
            <span class="c1"># the final starting point (not used below, since it is larger</span>
            <span class="c1"># than the largest self.rank value) is the total data length</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">starting_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">starting_points</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;- Rank </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="si">}</span><span class="s2"> writing output to </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">start</span><span class="o">+</span><span class="n">chunk_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>



    <span class="k">def</span> <span class="nf">setup_photometry_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">photo_file</span><span class="p">,</span> <span class="n">target_size</span><span class="p">):</span>
        <span class="c1"># Get a list of all the column names</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ra&#39;</span><span class="p">,</span> <span class="s1">&#39;dec&#39;</span><span class="p">,</span> <span class="s1">&#39;extendedness&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_err&#39;</span><span class="p">)</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;extra_cols&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
            <span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Make group for all the photometry</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">photo_file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;photometry&#39;</span><span class="p">)</span>

        <span class="c1"># Extensible columns becase we don&#39;t know the size yet.</span>
        <span class="c1"># We will cut down the size at the end.</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>

        <span class="c1"># The only non-float column for now</span>
        <span class="n">group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>



    <span class="k">def</span> <span class="nf">setup_metacal_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metacal_file</span><span class="p">,</span> <span class="n">target_size</span><span class="p">):</span>
        <span class="c1"># Get a list of all the column names</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;ra&#39;</span><span class="p">,</span> <span class="s1">&#39;dec&#39;</span><span class="p">,</span> <span class="s1">&#39;psf_g1&#39;</span><span class="p">,</span> <span class="s1">&#39;psf_g2&#39;</span><span class="p">,</span> <span class="s1">&#39;mcal_psf_g1&#39;</span><span class="p">,</span> <span class="s1">&#39;mcal_psf_g2&#39;</span><span class="p">,</span> <span class="s1">&#39;mcal_psf_T_mean&#39;</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">metacal_variants</span><span class="p">(</span><span class="s1">&#39;mcal_g1&#39;</span><span class="p">,</span> <span class="s1">&#39;mcal_g2&#39;</span><span class="p">,</span> <span class="s1">&#39;mcal_T&#39;</span><span class="p">,</span> <span class="s1">&#39;mcal_s2n&#39;</span><span class="p">,</span>  <span class="s1">&#39;mcal_T_err&#39;</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">band_variants</span><span class="p">(</span><span class="s1">&#39;riz&#39;</span><span class="p">,</span> <span class="s1">&#39;mcal_mag&#39;</span><span class="p">,</span> <span class="s1">&#39;mcal_mag_err&#39;</span><span class="p">,</span><span class="n">shear_catalog_type</span><span class="o">=</span><span class="s1">&#39;metacal&#39;</span><span class="p">)</span>
            <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">cols</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;true_g1&#39;</span><span class="p">,</span> <span class="s1">&#39;true_g2&#39;</span><span class="p">,</span> <span class="s1">&#39;redshift_true&#39;</span><span class="p">]</span>

        <span class="c1"># Make group for all the photometry</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">metacal_file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;shear&#39;</span><span class="p">)</span>

        <span class="c1"># Extensible columns becase we don&#39;t know the size yet.</span>
        <span class="c1"># We will cut down the size at the end.</span>
        

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f8&#39;</span><span class="p">)</span>

        <span class="n">group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>
        <span class="n">group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mcal_flags&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">maxshape</span><span class="o">=</span><span class="p">(</span><span class="n">target_size</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;i8&#39;</span><span class="p">)</span>


        <span class="k">return</span> <span class="n">cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span>  <span class="s1">&#39;mcal_flags&#39;</span><span class="p">]</span>
        

<div class="viewcode-block" id="TXCosmoDC2Mock.load_metacal_response_model"><a class="viewcode-back" href="../../stages/input_cats.html#txpipe.input_cats.TXCosmoDC2Mock.load_metacal_response_model">[docs]</a>    <span class="k">def</span> <span class="nf">load_metacal_response_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load an HDF file containing the response model</span>
<span class="sd">        R(log10(snr), size)</span>
<span class="sd">        R_std(log10(snr), size)</span>

<span class="sd">        where R is the mean metacal response in a bin and</span>
<span class="sd">        R_std is its standard deviation.</span>

<span class="sd">        So far only one of these files exists!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">scipy.interpolate</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;unit_response&#39;</span><span class="p">]:</span>
            <span class="k">return</span>

        <span class="n">model_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_input</span><span class="p">(</span><span class="s2">&quot;response_model&quot;</span><span class="p">)</span>
        <span class="n">snr_centers</span> <span class="o">=</span> <span class="n">model_file</span><span class="p">[</span><span class="s1">&#39;R_model/log10_snr&#39;</span><span class="p">][:]</span>
        <span class="n">sz_centers</span> <span class="o">=</span> <span class="n">model_file</span><span class="p">[</span><span class="s1">&#39;R_model/size&#39;</span><span class="p">][:]</span>
        <span class="n">R_mean</span> <span class="o">=</span> <span class="n">model_file</span><span class="p">[</span><span class="s1">&#39;R_model/R_mean&#39;</span><span class="p">][:]</span>
        <span class="n">R_std</span> <span class="o">=</span> <span class="n">model_file</span><span class="p">[</span><span class="s1">&#39;R_model/R_std&#39;</span><span class="p">][:]</span>
        <span class="n">model_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Save a 2D spline</span>
        <span class="n">snr_grid</span><span class="p">,</span> <span class="n">sz_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">snr_centers</span><span class="p">,</span> <span class="n">sz_centers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">R_spline</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">SmoothBivariateSpline</span><span class="p">(</span><span class="n">snr_grid</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">sz_grid</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">R_mean</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">w</span><span class="o">=</span><span class="n">R_std</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Rstd_spline</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">SmoothBivariateSpline</span><span class="p">(</span><span class="n">snr_grid</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">sz_grid</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">R_std</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>        </div>


<div class="viewcode-block" id="TXCosmoDC2Mock.write_output"><a class="viewcode-back" href="../../stages/input_cats.html#txpipe.input_cats.TXCosmoDC2Mock.write_output">[docs]</a>    <span class="k">def</span> <span class="nf">write_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">target_size</span><span class="p">,</span> <span class="n">photo_cols</span><span class="p">,</span> <span class="n">metacal_cols</span><span class="p">,</span> <span class="n">photo_file</span><span class="p">,</span> <span class="n">photo_data</span><span class="p">,</span> <span class="n">metacal_file</span><span class="p">,</span> <span class="n">metacal_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the photometry we have just simulated to disc</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        photo_file: HDF File object</span>

<span class="sd">        metacal_file: HDF File object</span>

<span class="sd">        photo_data: dict</span>
<span class="sd">            Dictionary of simulated photometry</span>

<span class="sd">        metacal_data: dict</span>
<span class="sd">            Dictionary of simulated metacal data</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Work out the range of data to output (since we will be</span>
        <span class="c1"># doing this in chunks). If we have cut down to a random</span>
        <span class="c1"># subset of the catalog then we may have gone over the</span>
        <span class="c1"># target length, depending on the random selection</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">photo_data</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">target_size</span><span class="p">)</span>

        <span class="c1">#assert photo_data[&#39;id&#39;].min()&gt;0</span>

        <span class="c1"># Save each column</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">photo_cols</span><span class="p">:</span>
            <span class="n">photo_file</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;photometry/</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">photo_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">metacal_cols</span><span class="p">:</span>
            <span class="n">metacal_file</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;shear/</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">metacal_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">make_mock_photometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># The visit count affects the overall noise levels</span>
        <span class="n">n_visit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;visits_per_band&#39;</span><span class="p">]</span>
        <span class="c1"># Do all the work in the function below</span>
        <span class="n">photo</span> <span class="o">=</span> <span class="n">make_mock_photometry</span><span class="p">(</span><span class="n">n_visit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;unit_response&#39;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;extra_cols&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
            <span class="n">photo</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">photo</span>



<div class="viewcode-block" id="TXCosmoDC2Mock.make_mock_metacal"><a class="viewcode-back" href="../../stages/input_cats.html#txpipe.input_cats.TXCosmoDC2Mock.make_mock_metacal">[docs]</a>    <span class="k">def</span> <span class="nf">make_mock_metacal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">photo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a mock metacal table.</span>
<span class="sd">        This is a long and complicated function unfortunately.</span>

<span class="sd">        Throughout we assume a single R = R11 = R22, with R12 = R21 = 0</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: dict</span>
<span class="sd">            Dictionary of arrays read from the input cosmo catalog</span>
<span class="sd">        photo: dict</span>
<span class="sd">            Dictionary of arrays generated to simulate photometry</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># These are the numbers from figure F1 of the DES Y1 shear catalog paper</span>
        <span class="c1"># (this version is not yet public but is awaiting a second referee response)</span>

        <span class="c1"># Overall SNR for the three bands usually used for shape measurement</span>
        <span class="c1"># We use the true SNR not the estimated one, though these are pretty close</span>
        <span class="n">snr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_r&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
            <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_i&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> 
            <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_z&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">snr_1p</span> <span class="o">=</span> <span class="p">(</span><span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_r_1p&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_i_1p&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_z_1p&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">snr_1m</span> <span class="o">=</span> <span class="p">(</span><span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_r_1m&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_i_1m&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_z_1m&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">snr_2p</span> <span class="o">=</span> <span class="p">(</span><span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_r_2p&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_i_2p&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_z_2p&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">snr_2m</span> <span class="o">=</span> <span class="p">(</span><span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_r_2m&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_i_2m&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;snr_z_2m&#39;</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;unit_response&#39;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="n">snr_1p</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">snr</span><span class="p">,</span> <span class="n">snr_2m</span><span class="p">)</span>
        
        <span class="n">nobj</span> <span class="o">=</span> <span class="n">snr</span><span class="o">.</span><span class="n">size</span>

        <span class="n">log10_snr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">snr</span><span class="p">)</span>

        <span class="c1"># Convert from the half-light radius which is in the </span>
        <span class="c1"># input catalogs to a sigma.  Do this by pretending</span>
        <span class="c1"># that it is a Gaussian.  This is clearly wrong, and</span>
        <span class="c1"># if this causes major errors in the size cuts we may</span>
        <span class="c1"># have to modify this</span>
        <span class="n">size_hlr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;size_true&#39;</span><span class="p">]</span>
        <span class="n">size_sigma</span> <span class="o">=</span> <span class="n">size_hlr</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">size_T</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">size_sigma</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Use a fixed PSF across all the objects</span>
        <span class="n">psf_fwhm</span> <span class="o">=</span> <span class="mf">0.75</span>
        <span class="n">psf_sigma</span> <span class="o">=</span> <span class="n">psf_fwhm</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">psf_T</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">psf_sigma</span><span class="o">**</span><span class="mi">2</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;unit_response&#39;</span><span class="p">]:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">R_size</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the response model to get a reasonable response</span>
            <span class="c1"># value for this size and SNR</span>
            <span class="n">R_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R_spline</span><span class="p">(</span><span class="n">log10_snr</span><span class="p">,</span> <span class="n">size_T</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">R_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rstd_spline</span><span class="p">(</span><span class="n">log10_snr</span><span class="p">,</span> <span class="n">size_T</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            
            <span class="c1"># Assume a 0.2 correlation between the size response</span>
            <span class="c1"># and the shear response.</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.2</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span><span class="n">rho</span><span class="p">],[</span><span class="n">rho</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]],</span> <span class="n">nobj</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">R</span><span class="p">,</span> <span class="n">R_size</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">R_std</span> <span class="o">+</span> <span class="n">R_mean</span>

        <span class="c1"># Convert magnitudes to fluxes according to the baseline</span>
        <span class="c1"># use in the metacal numbers</span>
        <span class="n">flux_r</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mf">0.4</span><span class="o">*</span><span class="p">(</span><span class="mi">27</span> <span class="o">-</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r&#39;</span><span class="p">])</span>
        <span class="n">flux_i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mf">0.4</span><span class="o">*</span><span class="p">(</span><span class="mi">27</span> <span class="o">-</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i&#39;</span><span class="p">])</span>
        <span class="n">flux_z</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mf">0.4</span><span class="o">*</span><span class="p">(</span><span class="mi">27</span> <span class="o">-</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z&#39;</span><span class="p">])</span>

        <span class="c1"># Note that this is delta_gamma not 2*delta_gamma, because</span>
        <span class="c1"># of how we use it below</span>
        <span class="n">delta_gamma</span> <span class="o">=</span> <span class="mf">0.01</span>
        
        <span class="c1"># Use a fixed shape noise per component to generate </span>
        <span class="c1"># an overall </span>
        <span class="n">shape_noise</span> <span class="o">=</span> <span class="mf">0.26</span>
        <span class="n">eps</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">shape_noise</span><span class="p">,</span><span class="n">nobj</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">shape_noise</span><span class="p">,</span><span class="n">nobj</span><span class="p">)</span>
        <span class="c1"># True shears without shape noise</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shear_1&#39;</span><span class="p">]</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shear_2&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;flip_g2&#39;</span><span class="p">]:</span>
            <span class="n">g2</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Do the full combination of (g,epsilon) -&gt; e, not the approx one</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">g2</span>
        <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">eps</span> <span class="o">+</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">g</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">*</span><span class="n">eps</span><span class="p">)</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">real</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">imag</span>
    
        <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nobj</span><span class="p">)</span>
        <span class="c1"># Now collect together everything to go into the metacal</span>
        <span class="c1"># file</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># Basic values</span>
            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span>
            <span class="s1">&#39;ra&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;ra&#39;</span><span class="p">],</span>
            <span class="s1">&#39;dec&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;dec&#39;</span><span class="p">],</span>
            <span class="c1"># Keep the truth value just in case</span>
            <span class="s2">&quot;true_g1&quot;</span><span class="p">:</span> <span class="n">g1</span><span class="p">,</span>
            <span class="s2">&quot;true_g2&quot;</span><span class="p">:</span> <span class="n">g2</span><span class="p">,</span>
            <span class="c1"># add true redshift since it is used in source selector</span>
            <span class="s2">&quot;redshift_true&quot;</span><span class="p">:</span><span class="n">photo</span><span class="p">[</span><span class="s1">&#39;redshift_true&#39;</span><span class="p">],</span>
            

            <span class="c1"># g1</span>
            <span class="s2">&quot;mcal_g1&quot;</span><span class="p">:</span> <span class="n">e1</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;mcal_g1_1p&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e1</span><span class="o">+</span><span class="n">delta_gamma</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;mcal_g1_1m&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e1</span><span class="o">-</span><span class="n">delta_gamma</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;mcal_g1_2p&quot;</span><span class="p">:</span> <span class="n">e1</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;mcal_g1_2m&quot;</span><span class="p">:</span> <span class="n">e1</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>

            <span class="c1"># g2</span>
            <span class="s2">&quot;mcal_g2&quot;</span><span class="p">:</span> <span class="n">e2</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;mcal_g2_1p&quot;</span><span class="p">:</span> <span class="n">e2</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;mcal_g2_1m&quot;</span><span class="p">:</span> <span class="n">e2</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;mcal_g2_2p&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e2</span><span class="o">+</span><span class="n">delta_gamma</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;mcal_g2_2m&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">e2</span><span class="o">-</span><span class="n">delta_gamma</span><span class="p">)</span><span class="o">*</span><span class="n">R</span><span class="p">,</span>

            <span class="c1"># T</span>
            <span class="s2">&quot;mcal_T&quot;</span><span class="p">:</span> <span class="n">size_T</span><span class="p">,</span>
            <span class="s2">&quot;mcal_T_1p&quot;</span><span class="p">:</span> <span class="n">size_T</span> <span class="o">+</span> <span class="n">R_size</span><span class="o">*</span><span class="n">delta_gamma</span><span class="p">,</span>
            <span class="s2">&quot;mcal_T_1m&quot;</span><span class="p">:</span> <span class="n">size_T</span> <span class="o">-</span> <span class="n">R_size</span><span class="o">*</span><span class="n">delta_gamma</span><span class="p">,</span>
            <span class="s2">&quot;mcal_T_2p&quot;</span><span class="p">:</span> <span class="n">size_T</span> <span class="o">+</span> <span class="n">R_size</span><span class="o">*</span><span class="n">delta_gamma</span><span class="p">,</span>
            <span class="s2">&quot;mcal_T_2m&quot;</span><span class="p">:</span> <span class="n">size_T</span> <span class="o">-</span> <span class="n">R_size</span><span class="o">*</span><span class="n">delta_gamma</span><span class="p">,</span>

            <span class="c1"># Terr</span>
            <span class="s2">&quot;mcal_T_err&quot;</span><span class="p">:</span>    <span class="n">zero</span><span class="p">,</span>
            <span class="s2">&quot;mcal_T_err_1p&quot;</span><span class="p">:</span> <span class="n">zero</span><span class="p">,</span>
            <span class="s2">&quot;mcal_T_err_1m&quot;</span><span class="p">:</span> <span class="n">zero</span><span class="p">,</span>
            <span class="s2">&quot;mcal_T_err_2p&quot;</span><span class="p">:</span> <span class="n">zero</span><span class="p">,</span>
            <span class="s2">&quot;mcal_T_err_2m&quot;</span><span class="p">:</span> <span class="n">zero</span><span class="p">,</span>

            <span class="c1"># size </span>
            <span class="s2">&quot;mcal_s2n&quot;</span><span class="p">:</span> <span class="n">snr</span><span class="p">,</span>
            <span class="s2">&quot;mcal_s2n_1p&quot;</span><span class="p">:</span> <span class="n">snr_1p</span><span class="p">,</span>
            <span class="s2">&quot;mcal_s2n_1m&quot;</span><span class="p">:</span> <span class="n">snr_1m</span><span class="p">,</span>
            <span class="s2">&quot;mcal_s2n_2p&quot;</span><span class="p">:</span> <span class="n">snr_2p</span><span class="p">,</span>
            <span class="s2">&quot;mcal_s2n_2m&quot;</span><span class="p">:</span> <span class="n">snr_2m</span><span class="p">,</span>

            <span class="c1"># Magntiudes and fluxes, just copied from the inputs.</span>
            <span class="s1">&#39;mcal_mag_r&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_i&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_z&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z&#39;</span><span class="p">],</span>

            <span class="s1">&#39;mcal_mag_err_r&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_i&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_z&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_err&#39;</span><span class="p">],</span>

            <span class="s1">&#39;mcal_mag_r_1p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_1p&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_r_2p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_2p&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_r_1m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_1m&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_r_2m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_2m&#39;</span><span class="p">],</span>

            <span class="s1">&#39;mcal_mag_i_1p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_1p&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_i_2p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_2p&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_i_1m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_1m&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_i_2m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_2m&#39;</span><span class="p">],</span>
            
            <span class="s1">&#39;mcal_mag_z_1p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_1p&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_z_2p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_2p&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_z_1m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_1m&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_z_2m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_2m&#39;</span><span class="p">],</span>

            <span class="s1">&#39;mcal_mag_err_r_1p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_r_2p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_r_1m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_r_2m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_r_err&#39;</span><span class="p">],</span>

            <span class="s1">&#39;mcal_mag_err_i_1p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_i_2p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_i_1m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_i_2m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_i_err&#39;</span><span class="p">],</span>

            <span class="s1">&#39;mcal_mag_err_z_1p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_z_2p&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_z_1m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_err&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mcal_mag_err_z_2m&#39;</span><span class="p">:</span> <span class="n">photo</span><span class="p">[</span><span class="s1">&#39;mag_z_err&#39;</span><span class="p">],</span>

            <span class="c1"># Fixed PSF parameters - all round with same size</span>
            <span class="s1">&#39;mcal_psf_g1&#39;</span><span class="p">:</span> <span class="n">zero</span><span class="p">,</span>
            <span class="s1">&#39;mcal_psf_g2&#39;</span><span class="p">:</span> <span class="n">zero</span><span class="p">,</span>
            <span class="s1">&#39;psf_g1&#39;</span><span class="p">:</span> <span class="n">zero</span><span class="p">,</span>
            <span class="s1">&#39;psf_g2&#39;</span><span class="p">:</span> <span class="n">zero</span><span class="p">,</span>
            <span class="s1">&#39;mcal_psf_T_mean&#39;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">psf_T</span><span class="p">,</span> <span class="n">nobj</span><span class="p">),</span>

            <span class="c1"># Everything that gets this far should be used, so flag=0</span>
            <span class="s1">&#39;mcal_flags&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nobj</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="c1"># we use weights of one for everything for metacal</span>
            <span class="c1"># if that ever changes we may also need to add</span>
            <span class="c1"># weight_1p, etc.</span>
            <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nobj</span><span class="p">),</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="TXCosmoDC2Mock.apply_magnitude_cut"><a class="viewcode-back" href="../../stages/input_cats.html#txpipe.input_cats.TXCosmoDC2Mock.apply_magnitude_cut">[docs]</a>    <span class="k">def</span> <span class="nf">apply_magnitude_cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow for a cut in absolute magnitude.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mag_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;Mag_r_limit&#39;</span><span class="p">]</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Mag_true_r_sdss_z0&#39;</span><span class="p">]</span><span class="o">&lt;</span> <span class="n">mag_limit</span>
        
        <span class="n">ndet</span> <span class="o">=</span> <span class="n">sel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntot</span> <span class="o">=</span> <span class="n">sel</span><span class="o">.</span><span class="n">size</span>
        <span class="n">fract</span> <span class="o">=</span> <span class="n">ndet</span><span class="o">*</span><span class="mf">100.</span><span class="o">/</span><span class="n">ntot</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ndet</span><span class="si">}</span><span class="s2"> objects pass magnitude cut out of </span><span class="si">{</span><span class="n">ntot</span><span class="si">}</span><span class="s2"> objects (</span><span class="si">{</span><span class="n">fract</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>

        <span class="c1"># Remove all objects not selected</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">sel</span><span class="p">]</span></div>


<div class="viewcode-block" id="TXCosmoDC2Mock.remove_undetected"><a class="viewcode-back" href="../../stages/input_cats.html#txpipe.input_cats.TXCosmoDC2Mock.remove_undetected">[docs]</a>    <span class="k">def</span> <span class="nf">remove_undetected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">photo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Strip out any undetected objects from the two</span>
<span class="sd">        simulated data sets.</span>

<span class="sd">        Use a configuration parameter snr_limit to decide</span>
<span class="sd">        on the detection limit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">snr_limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;snr_limit&#39;</span><span class="p">]</span>

        <span class="c1"># This will become a boolean array in a minute when</span>
        <span class="c1"># we OR it with an array</span>
        <span class="n">detected</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check if detected in any band.  Makes a boolean array</span>
        <span class="c1"># Even though we started with just a single False.</span>
        <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bands</span><span class="p">:</span>
            <span class="n">detected_in_band</span> <span class="o">=</span> <span class="n">photo</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_limit</span>
            <span class="n">not_detected_in_band</span> <span class="o">=</span> <span class="o">~</span><span class="n">detected_in_band</span>
            <span class="c1"># Set objects not detected in one band that are detected in another</span>
            <span class="c1"># to inf magnitude in that band, and the SNR to zero.</span>
            <span class="c1"># We have to do this for each of the variants also, because otherwise</span>
            <span class="c1"># we end up with wildly different final SNR values later.</span>
            <span class="c1"># This is the metadetection issue really!</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">metacal_variants</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="n">photo</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">not_detected_in_band</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">metacal_variants</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="n">photo</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">not_detected_in_band</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="c1"># Record that we have detected this object at all</span>
            <span class="n">detected</span> <span class="o">|=</span> <span class="n">detected_in_band</span>


        <span class="c1"># the protoDC2 sims have an edge with zero shear.</span>
        <span class="c1"># Remove it.</span>
        <span class="n">zero_shear_edge</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;shear_1&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;shear_2&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removing </span><span class="si">{}</span><span class="s2"> objects with identically zero shear in both terms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zero_shear_edge</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>

        <span class="n">detected</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">zero_shear_edge</span><span class="p">)</span>

        <span class="c1"># Print out interesting information</span>
        <span class="n">ndet</span> <span class="o">=</span> <span class="n">detected</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">ntot</span> <span class="o">=</span> <span class="n">detected</span><span class="o">.</span><span class="n">size</span>
        <span class="n">fract</span> <span class="o">=</span> <span class="n">ndet</span><span class="o">*</span><span class="mf">100.</span><span class="o">/</span><span class="n">ntot</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="n">ndet</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="n">ntot</span><span class="si">}</span><span class="s2"> objects (</span><span class="si">{</span><span class="n">fract</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>

        <span class="c1"># Remove all objects not detected in *any* band</span>
        <span class="c1"># make a copy of the keys with list(photo.keys()) so we are not</span>
        <span class="c1"># modifying during the iteration</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">photo</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span> 
            <span class="n">photo</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">photo</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">detected</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">detected</span><span class="p">]</span></div></div>

<div class="viewcode-block" id="TXBuzzardMock"><a class="viewcode-back" href="../../stages/input_cats.html#txpipe.input_cats.TXBuzzardMock">[docs]</a><span class="k">class</span> <span class="nc">TXBuzzardMock</span><span class="p">(</span><span class="n">TXCosmoDC2Mock</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This stage simulates metacal data and metacalibrated</span>
<span class="sd">    photometry measurements, starting from a cosmology catalogs</span>
<span class="sd">    of the kind used as an input to DC2 image and obs-catalog simulations.</span>

<span class="sd">    This is mainly useful for testing infrastructure in advance</span>
<span class="sd">    of the DC2 catalogs being available, but might also be handy</span>
<span class="sd">    for starting from a purer simulation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;TXBuzzardMock&#39;</span>

    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;response_model&#39;</span><span class="p">,</span> <span class="n">HDFFile</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;shear_catalog&#39;</span><span class="p">,</span> <span class="n">ShearCatalog</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;photometry_catalog&#39;</span><span class="p">,</span> <span class="n">HDFFile</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="n">config_options</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;cat_name&#39;</span><span class="p">:</span><span class="s1">&#39;buzzard&#39;</span><span class="p">,</span>
        <span class="s1">&#39;visits_per_band&#39;</span><span class="p">:</span><span class="mi">165</span><span class="p">,</span>  <span class="c1"># used in the noise simulation</span>
        <span class="s1">&#39;snr_limit&#39;</span><span class="p">:</span><span class="mf">4.0</span><span class="p">,</span>  <span class="c1"># used to decide what objects to cut out</span>
        <span class="s1">&#39;max_size&#39;</span><span class="p">:</span> <span class="mi">99999999999999</span><span class="p">,</span>  <span class="c1">#for testing on smaller catalogs</span>
        <span class="s1">&#39;extra_cols&#39;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="c1"># string-separated list of columns to include</span>
        <span class="s1">&#39;max_npix&#39;</span><span class="p">:</span><span class="mi">99999999999999</span><span class="p">,</span>
        <span class="s1">&#39;unit_response&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s1">&#39;flip_g2&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="c1"># this matches the metacal definition, and the treecorr/namaster one</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="make_mock_photometry"><a class="viewcode-back" href="../../stages/input_cats.html#txpipe.input_cats.make_mock_photometry">[docs]</a><span class="k">def</span> <span class="nf">make_mock_photometry</span><span class="p">(</span><span class="n">n_visit</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">unit_response</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a mock photometric table with noise added</span>

<span class="sd">    This is mostly from LSE40 by </span>
<span class="sd">    Zeljko Ivezic, Lynne Jones, and Robert Lupton</span>
<span class="sd">    retrieved here:</span>
<span class="sd">    http://faculty.washington.edu/ivezic/Teaching/Astr511/LSST_SNRdoc.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">nobj</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;galaxy_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;ra&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ra&#39;</span><span class="p">]</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;dec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;dec&#39;</span><span class="p">]</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;galaxy_id&#39;</span><span class="p">]</span>
    <span class="n">output</span><span class="p">[</span><span class="s1">&#39;extendedness&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nobj</span><span class="p">)</span>

    <span class="c1"># Sky background, seeing FWHM, and system throughput, </span>
    <span class="c1"># all from table 2 of Ivezic, Jones, &amp; Lupton</span>
    <span class="n">B_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">85.07</span><span class="p">,</span> <span class="mf">467.9</span><span class="p">,</span> <span class="mf">1085.2</span><span class="p">,</span> <span class="mf">1800.3</span><span class="p">,</span> <span class="mf">2775.7</span><span class="p">,</span> <span class="mf">3614.3</span><span class="p">])</span>
    <span class="n">fwhm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.77</span><span class="p">,</span> <span class="mf">0.73</span><span class="p">,</span> <span class="mf">0.70</span><span class="p">,</span> <span class="mf">0.67</span><span class="p">,</span> <span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.63</span><span class="p">])</span>
    <span class="n">T_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0379</span><span class="p">,</span> <span class="mf">0.1493</span><span class="p">,</span> <span class="mf">0.1386</span><span class="p">,</span> <span class="mf">0.1198</span><span class="p">,</span> <span class="mf">0.0838</span><span class="p">,</span> <span class="mf">0.0413</span><span class="p">])</span>


    <span class="c1"># effective pixels size for a Gaussian PSF, from equation</span>
    <span class="c1"># 27 of Ivezic, Jones, &amp; Lupton</span>
    <span class="n">pixel</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># arcsec</span>
    <span class="n">N_eff</span> <span class="o">=</span> <span class="mf">2.436</span> <span class="o">*</span> <span class="p">(</span><span class="n">fwhm</span><span class="o">/</span><span class="n">pixel</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>


    <span class="c1"># other numbers from Ivezic, Jones, &amp; Lupton</span>
    <span class="n">sigma_inst2</span> <span class="o">=</span> <span class="mf">10.0</span><span class="o">**</span><span class="mi">2</span>  <span class="c1">#instrumental noise in photons per pixel, just below eq 42</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># ADU units per photon, also just below eq 42</span>
    <span class="n">D</span> <span class="o">=</span> <span class="mf">6.5</span> <span class="c1"># primary mirror diameter in meters, from LSST key numbers page (effective clear diameter)</span>
    <span class="c1"># Not sure what effective clear diameter means but it&#39;s closer to the number used in the paper</span>
    <span class="n">time</span> <span class="o">=</span> <span class="mf">30.</span> <span class="c1"># seconds per exposure, from LSST key numbers page</span>
    <span class="n">sigma_b2</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># error on background, just above eq 42</span>

    <span class="c1"># combination of these  used below, from various equations</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="mf">5455.</span><span class="o">/</span><span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">D</span><span class="o">/</span><span class="mf">6.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">time</span><span class="o">/</span><span class="mf">30.</span><span class="p">)</span>

    <span class="c1"># Fake some metacal responses</span>
    <span class="k">if</span> <span class="n">unit_response</span><span class="p">:</span>
        <span class="n">mag_responses</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bands</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mag_responses</span> <span class="o">=</span> <span class="n">generate_mock_metacal_mag_responses</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">nobj</span><span class="p">)</span>

    <span class="n">delta_gamma</span> <span class="o">=</span> <span class="mf">0.01</span>  <span class="c1"># this is the half-delta gamma, i.e. gamma_+ - gamma_0</span>
    <span class="c1"># that&#39;s the right thing to use here because we are doing m+ = m0 + dm/dy*dy</span>
    <span class="c1"># Use the same response for gamma1 and gamma2</span>


    <span class="k">for</span> <span class="n">band</span><span class="p">,</span> <span class="n">b_b</span><span class="p">,</span> <span class="n">t_b</span><span class="p">,</span> <span class="n">n_eff</span><span class="p">,</span> <span class="n">mag_resp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">B_b</span><span class="p">,</span> <span class="n">T_b</span><span class="p">,</span> <span class="n">N_eff</span><span class="p">,</span> <span class="n">mag_responses</span><span class="p">):</span>
        <span class="c1"># truth magnitude</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_true_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_lsst&#39;</span><span class="p">]</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_true_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_lsst&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag</span>

        <span class="c1"># expected signal photons, over all visits</span>
        <span class="n">c_b</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="mf">0.4</span><span class="o">*</span><span class="p">(</span><span class="mi">25</span><span class="o">-</span><span class="n">mag</span><span class="p">))</span> <span class="o">*</span> <span class="n">t_b</span> <span class="o">*</span> <span class="n">n_visit</span>

        <span class="c1"># expected background photons, over all visits</span>
        <span class="n">background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">b_b</span> <span class="o">+</span> <span class="n">sigma_inst2</span> <span class="o">+</span> <span class="n">sigma_b2</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_eff</span> <span class="o">*</span> <span class="n">n_visit</span><span class="p">)</span>
        <span class="c1"># total expected photons</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">c_b</span> <span class="o">+</span> <span class="n">background</span>
        
        <span class="c1"># Observed number of photons in excess of the expected background.</span>
        <span class="c1"># This can go negative for faint magnitudes, indicating that the object is</span>
        <span class="c1"># not going to be detected</span>
        <span class="n">n_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">-</span> <span class="n">background</span>
        <span class="n">n_obs_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>

        <span class="c1"># signal to noise, true and estimated values</span>
        <span class="n">true_snr</span> <span class="o">=</span> <span class="n">c_b</span> <span class="o">/</span> <span class="n">background</span>
        <span class="n">obs_snr</span> <span class="o">=</span> <span class="n">n_obs</span> <span class="o">/</span> <span class="n">background</span>

        <span class="c1"># observed magnitude from inverting c_b expression above</span>
        <span class="n">mag_obs</span> <span class="o">=</span> <span class="mi">25</span> <span class="o">-</span> <span class="mf">2.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">n_obs</span><span class="o">/</span><span class="n">factor</span><span class="o">/</span><span class="n">t_b</span><span class="o">/</span><span class="n">n_visit</span><span class="p">)</span>

        <span class="c1"># converting error on n_obs to error on mag</span>
        <span class="n">mag_err</span> <span class="o">=</span> <span class="mf">2.5</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span> <span class="o">/</span> <span class="n">obs_snr</span>

        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;true_snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">true_snr</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obs_snr</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag_obs</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_err_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag_err</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mag_err</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">mag_resp</span><span class="o">*</span><span class="n">delta_gamma</span>

        <span class="n">m1</span> <span class="o">=</span> <span class="n">mag_obs</span> <span class="o">+</span> <span class="n">m</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">mag_obs</span> <span class="o">-</span> <span class="n">m</span>
        <span class="n">mag_obs_1p</span> <span class="o">=</span> <span class="n">m1</span>
        <span class="n">mag_obs_1m</span> <span class="o">=</span> <span class="n">m2</span>

        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_1p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m1</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_1m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m2</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_2p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m1</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_2m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m2</span>

        <span class="c1"># Scale the SNR values according the to change in magnitude.r</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>

        <span class="n">snr1</span> <span class="o">=</span> <span class="n">obs_snr</span> <span class="o">*</span> <span class="n">s</span>
        <span class="n">snr2</span> <span class="o">=</span> <span class="n">obs_snr</span> <span class="o">/</span> <span class="n">s</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_1p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snr1</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_1m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snr2</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_2p&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snr1</span>
        <span class="n">output</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;snr_</span><span class="si">{</span><span class="n">band</span><span class="si">}</span><span class="s1">_2m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snr2</span>



    <span class="k">return</span> <span class="n">output</span></div>



<span class="k">def</span> <span class="nf">generate_mock_metacal_mag_responses</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">nobj</span><span class="p">):</span>
    <span class="n">nband</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bands</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nband</span><span class="p">)</span> <span class="c1"># seems approx mean of response across bands, from HSC tract</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.25</span>  <span class="c1">#  approx correlation between response in bands, from HSC tract</span>
    <span class="n">sigma2</span> <span class="o">=</span> <span class="mf">1.7</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># approx variance of response, from HSC tract</span>
    <span class="n">covmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">nband</span><span class="p">,</span><span class="n">nband</span><span class="p">),</span> <span class="n">rho</span><span class="o">*</span><span class="n">sigma2</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">covmat</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">)</span>
    <span class="n">mag_responses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">covmat</span><span class="p">,</span> <span class="n">nobj</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">mag_responses</span>




<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">pylab</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;ra&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
        <span class="s1">&#39;dec&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
        <span class="s1">&#39;galaxy_id&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="s1">&#39;ugrizy&#39;</span>
    <span class="n">n_visit</span><span class="o">=</span><span class="mi">165</span>
    <span class="n">M5</span> <span class="o">=</span> <span class="p">[</span><span class="mf">24.22</span><span class="p">,</span> <span class="mf">25.17</span><span class="p">,</span> <span class="mf">24.74</span><span class="p">,</span> <span class="mf">24.38</span><span class="p">,</span> <span class="mf">23.80</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">b</span><span class="p">,</span><span class="n">m5</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bands</span><span class="p">,</span> <span class="n">M5</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mag_true_</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">_lsst&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">m5</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">make_mock_photometry</span><span class="p">(</span><span class="n">n_visit</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">pylab</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;snr_r&#39;</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;step&#39;</span><span class="p">)</span>
    <span class="n">pylab</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;snr_r.png&#39;</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, DESC.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>