from .base import HOSStage
from ...data_types import MapsFile, SACCFile, QPNOfZFile, HDFFile
import numpy as np



class HOSFSB(HOSStage):
    """
    Measure the filtered squared bispectrum (FSB) from over-density maps.

    This is a sub-class of the HOSStage class, which provides a set of useful
    methods for loading input map and mask data, and setting up an output sacc file.

    See https://doi.org/10.33232/001c.128309
    for details of the FSB method.
    
    """
    name = "HOSFSB"

    # Inputs needed by this stage. A list of all the files currently
    # generated by the pipeline that could be used here can be found at
    # https://txpipe.readthedocs.io/en/latest/files.html
    # The second items in the list are classes which represent types
    # of file.  A listing can be found here:
    # https://txpipe.readthedocs.io/en/latest/file_types.html
    # and the code is in txpipe/data_types/types.py
    inputs = [
        ("density_maps", MapsFile),
        ("mask", MapsFile),
        ("lens_photoz_stack", QPNOfZFile),
        ("tracer_metadata", HDFFile),
    ]

    # Similarly, a list of output files. Measured summary statistics
    # should generally be saved in a SACC file, which is the DESC format
    # for measurements. 
    # See https://sacc.readthedocs.io/ for details. 
    outputs = [
        ("filtered_squared_bispectrum", SACCFile),
    ]

    # This is a dictionary of configuration options. The keys are the
    # the names of the options, and the values are either default values,
    # or can be a type (str / int / float) if the user must specifiy the value.
    # These options are read from configuration files, or can be overridden on the
    # command line or in a notebook.
    config_options = {
        "ells_per_bin": 10,
        "nfilters": 5,
        "include_n32": False,
    }

    def run(self):
        import fsb_2fields
        import healpy

        # Read configuration information. Available values for this
        # are specified in the config_options dictionary above, along with
        # default values
        nfilters = self.config["nfilters"]

        # Load input data
        mask, pixel_scheme = self.load_mask()
        density_maps, nbin_lens = self.load_overdensity_maps(set_bad_pixels_to_zero=True)

        # Build the array of filters to be applied
        filters = fsb_2fields.get_filters(nfilters, pixel_scheme.nside)

        # TODO: Parallelize this loop
        # TODO: Add tomo bin cross-correlations
        measurements = []
        for i in range(nbin_lens):
            measurement = self.measure_fsb(density_maps[i], mask, filters)
            measurements.append(measurement)

        # TODO: If we parallelize this then make sure only the root process
        # saves the measurements
        self.save_measurements(measurements)
        
    def measure_fsb(self, density_map, mask, filters):
        """
        Measure the filtered squared bispectrum from the input density map.

        TODO: Update to allow for cross-correlations between tomographic bins.

        Parameters
        ----------
        density_map : array
            The input density map to be measured.
        
        mask : array
            The mask for this map

        filters : list
            The list of filters to be applied to the density map.
        """
        import fsb_2fields

        # Read more configuration information
        ells_per_bin = self.config["ells_per_bin"]
        include_n32 = self.config["include_n32"]

        # Initialize the main calculator object
        calculator = fsb_2fields.FSB(density_map, mask, filters, ells_per_bin=ells_per_bin)

        # get the ell values for the spectrum
        ells = calculator.bb.get_effective_ells()

        # We get the C_ell to make sure it is the same as that
        # computed in TXTwoPointFourier
        c_ells = calculator.cls_11_binned

        # For now we assume there is no covariance between the
        # tomographic bins, but if we want to calculate it we
        # could generate it by passing the pairs of maps to
        # the calculator above and calling get_full_cov on that.
        # This would also give use the cross-FSB
        cov = calculator.get_full_cov(n32=include_n32)

        # store the set of measurements           
        measurement = (
            ells,
            c_ells,
            calculator.fsb_binned,
            cov
        )

        return measurement

    def save_measurements(self, measurements):
        import sacc
        nbin_lens = len(measurements)

        # Get the pre-prepared output 
        s = self.prepare_output_sacc(nbin_lens=nbin_lens)

        # The two data type codes - one is standard, one is specific
        # to this statistic.
        fsb_data_type = "galaxy_density_filteredSquareBispectrum"
        cl_data_type = sacc.standard_types.galaxy_density_cl
        cov_blocks = []

        # Add measurements from each tomo bin one by one.
        # If we add cross-correlations we will need to
        # change the tracer names here.
        for i, m in enumerate(measurements):
            ells, c_ells, fsbs, cov = m

            # The 3-point functions have three tracers, and the C_ell spectra
            # only two, but in each case we are just doing auto-correlations for now
            fsb_tracers = (f"lens_{i}", f"lens_{i}", f"lens_{i}")
            cl_tracers = (f"lens_{i}", f"lens_{i}")

            n = 0
            # Save the 3pt data points
            for j in range(self.config["nfilters"]):
                for k, ell_eff in enumerate(ells):
                    s.add_data_point(fsb_data_type, fsb_tracers, fsbs[j, k], ell=ell_eff, tomo_bin=i, filter=j, ell_index=k)
                    n += 1

            # Save the C_ell data points. These should generally be the same as what is calculated
            # in TXTwoPointFourier, provided the masks are the same.
            for k, ell_eff in enumerate(ells):
                s.add_data_point(cl_data_type, cl_tracers, c_ells[k], ell=ell_eff, tomo_bin=i, ell_index=k)
                n += 1

            # Store this covariance chunk - full one is block-diagonal.
            cov_blocks.append(cov)

        # Add the covariance matrix to the data file. You can pass in either
        # a dense matrix, a list of blocks, or a diagonal array.
        s.add_covariance(cov_blocks)


        output_filename = self.get_output("filtered_squared_bispectrum")
        s.save_fits(output_filename, overwrite=True)
